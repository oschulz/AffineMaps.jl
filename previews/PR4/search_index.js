var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:module]","category":"page"},{"location":"api/#Types-and-constants","page":"API","title":"Types and constants","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:type, :constant]","category":"page"},{"location":"api/#Functions-and-macros","page":"API","title":"Functions and macros","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:macro, :function]","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [AffineMaps]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"api/#AffineMaps.AffineMaps","page":"API","title":"AffineMaps.AffineMaps","text":"AffineMaps\n\nImplements affine transformations in a modular way.\n\n\n\n\n\n","category":"module"},{"location":"api/#AffineMaps.AbstractAffineMap","page":"API","title":"AffineMaps.AbstractAffineMap","text":"abstract type AbstractAffineMap\n\nAbstract type for affine maps.\n\nAffine map f::AbstractAffineMap act like f(x) == A * x + b or f(x) == A * (x + b) or their inverses, depending on the type of the map f.\n\nA may be a Number,  AbstractMatrix{<:Number} or any other multiplicative linear operator in general (that supports at least size(A) and eltype(A)). The packages LinearMaps, LinearOperators and SciMLOperators provide such operators, for example.\n\nb must support addition and subtraction with x, so it may be a Number or AbstractVector{<:Number}, depending on the type of x.\n\nSubtypes of AbstractAffineMap should implement/support the APIs of\n\nInverseFunctions.jl\nChangesOfVariables.jl\nFunctors.jl\n\n\n\n\n\n","category":"type"},{"location":"api/#AffineMaps.Add","page":"API","title":"AffineMaps.Add","text":"struct Add\n\nf = Add(b) has the behavior f(x) == x + f.b.\n\nSee AbstractAffineMap for more information.\n\n\n\n\n\n","category":"type"},{"location":"api/#AffineMaps.AddMul","page":"API","title":"AffineMaps.AddMul","text":"struct AddMul\n\nf = AddMul(A, b) has the behavior f(x) == f.A * (x + f.b).\n\nSee AbstractAffineMap for more information.\n\n\n\n\n\n","category":"type"},{"location":"api/#AffineMaps.InvAddMul","page":"API","title":"AffineMaps.InvAddMul","text":"muladd(f.A, x, f.b)     struct InvAddMul\n\nf = InvAddMul(A, b) has the behavior f(x) == (f.A \\ x) - f.b. It is the inverse of AddMul(A, b).\n\nSee AbstractAffineMap for more information.\n\n\n\n\n\n","category":"type"},{"location":"api/#AffineMaps.InvMul","page":"API","title":"AffineMaps.InvMul","text":"struct InvMul\n\nf = InvMul(A) has the behavior f(x) == f.A \\ x. It is the inverse of Mul(A).\n\nSee AbstractAffineMap for more information.\n\n\n\n\n\n","category":"type"},{"location":"api/#AffineMaps.InvMulAdd","page":"API","title":"AffineMaps.InvMulAdd","text":"struct InvMulAdd\n\nf = InvMulAdd(A, b) has the behavior f(x) == f.A \\ (x - f.b). It is the inverse of MulAdd(A, b).\n\nSee AbstractAffineMap for more information.\n\n\n\n\n\n","category":"type"},{"location":"api/#AffineMaps.Mul","page":"API","title":"AffineMaps.Mul","text":"struct Mul\n\nf = Mul(A) has the behavior f(x) == f.A * x.\n\nSee AbstractAffineMap for more information.\n\n\n\n\n\n","category":"type"},{"location":"api/#AffineMaps.MulAdd","page":"API","title":"AffineMaps.MulAdd","text":"struct MulAdd\n\nf = MulAdd(A, b) has the behavior f(x) == f.A * x + f.b.\n\nSee AbstractAffineMap for more information.\n\n\n\n\n\n","category":"type"},{"location":"api/#AffineMaps.Subtract","page":"API","title":"AffineMaps.Subtract","text":"struct Subtract\n\nf = Subtract(b) has the behavior f(x) == x - f.b. It is the inverse of Add(b).\n\nSee AbstractAffineMap for more information.\n\n\n\n\n\n","category":"type"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"#AffineMaps.jl","page":"Home","title":"AffineMaps.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AffineMaps.jl implements Affine maps. It provides the function object types Mul, Add, MulAdd and AddMul, as well as their inverses.","category":"page"},{"location":"","page":"Home","title":"Home","text":"All function objects defined here support the implement/support the APIs of","category":"page"},{"location":"","page":"Home","title":"Home","text":"InverseFunctions.jl\nChangesOfVariables.jl\nFunctors.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using AffineMaps\nusing LinearAlgebra, InverseFunctions, ChangesOfVariables\nA = rand(5, 5)\nb = rand(5)\nx = rand(5)\n\nf = MulAdd(A, b)\ny = f(x)\ny ≈ A * x + b","category":"page"},{"location":"","page":"Home","title":"Home","text":"inverse(f)(y) ≈ x","category":"page"},{"location":"","page":"Home","title":"Home","text":"y, ladj = with_logabsdet_jacobian(f, x)\ny ≈ A * x + b && ladj ≈ logabsdet(A)[1]","category":"page"}]
}
