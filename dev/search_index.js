var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Modules","page":"API","title":"Modules","text":"Order = [:module]","category":"section"},{"location":"api/#Types-and-constants","page":"API","title":"Types and constants","text":"Order = [:type, :constant]","category":"section"},{"location":"api/#Functions-and-macros","page":"API","title":"Functions and macros","text":"Order = [:macro, :function]","category":"section"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/#AffineMaps.AffineMaps","page":"API","title":"AffineMaps.AffineMaps","text":"AffineMaps\n\nImplements affine transformations in a modular way.\n\n\n\n\n\n","category":"module"},{"location":"api/#AffineMaps.AbstractAffineMap","page":"API","title":"AffineMaps.AbstractAffineMap","text":"abstract type AbstractAffineMap <: Function\n\nAbstract type for affine maps.\n\nAffine map f::AbstractAffineMap act like f(x) == A * x .+ b or f(x) == A * (x .+ b) or their inverses, depending on the type of the map f.\n\nA may be a Number,  AbstractMatrix{<:Number} or any other multiplicative linear operator in general (that supports at least size(A) and eltype(A)). The packages LinearMaps, LinearOperators and SciMLOperators provide such operators, for example.\n\nb must have a shape that supports broadcasted addition and subtraction with x.\n\nSubtypes of AbstractAffineMap should implement/support the APIs of\n\nInverseFunctions.jl\nChangesOfVariables.jl\nFunctors.jl\n\n\n\n\n\n","category":"type"},{"location":"api/#AffineMaps.Add","page":"API","title":"AffineMaps.Add","text":"struct Add\n\nf = Add(b) has the behavior f(x) == x .+ f.b.\n\nSee AbstractAffineMap for more information.\n\n\n\n\n\n","category":"type"},{"location":"api/#AffineMaps.AddMul","page":"API","title":"AffineMaps.AddMul","text":"struct AddMul\n\nf = AddMul(A, b) has the behavior f(x) == f.A * (x .+ f.b).\n\nSee AbstractAffineMap for more information.\n\n\n\n\n\n","category":"type"},{"location":"api/#AffineMaps.InvAddMul","page":"API","title":"AffineMaps.InvAddMul","text":"muladd(f.A, x, f.b)     struct InvAddMul\n\nf = InvAddMul(A, b) has the behavior f(x) == (f.A \\ x) .- f.b. It is the inverse of AddMul(A, b).\n\nSee AbstractAffineMap for more information.\n\n\n\n\n\n","category":"type"},{"location":"api/#AffineMaps.InvMul","page":"API","title":"AffineMaps.InvMul","text":"struct InvMul\n\nf = InvMul(A) has the behavior f(x) == f.A \\ x. It is the inverse of Mul(A).\n\nSee AbstractAffineMap for more information.\n\n\n\n\n\n","category":"type"},{"location":"api/#AffineMaps.InvMulAdd","page":"API","title":"AffineMaps.InvMulAdd","text":"struct InvMulAdd\n\nf = InvMulAdd(A, b) has the behavior f(x) == f.A \\ (x .- f.b). It is the inverse of MulAdd(A, b).\n\nSee AbstractAffineMap for more information.\n\n\n\n\n\n","category":"type"},{"location":"api/#AffineMaps.Mul","page":"API","title":"AffineMaps.Mul","text":"struct Mul\n\nf = Mul(A) has the behavior f(x) == f.A * x.\n\nSee AbstractAffineMap for more information.\n\n\n\n\n\n","category":"type"},{"location":"api/#AffineMaps.MulAdd","page":"API","title":"AffineMaps.MulAdd","text":"struct MulAdd\n\nf = MulAdd(A, b) has the behavior f(x) == f.A * x .+ f.b.\n\nSee AbstractAffineMap for more information.\n\n\n\n\n\n","category":"type"},{"location":"api/#AffineMaps.Subtract","page":"API","title":"AffineMaps.Subtract","text":"struct Subtract\n\nf = Subtract(b) has the behavior f(x) == x .- f.b. It is the inverse of Add(b).\n\nSee AbstractAffineMap for more information.\n\n\n\n\n\n","category":"type"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"section"},{"location":"#AffineMaps.jl","page":"Home","title":"AffineMaps.jl","text":"AffineMaps.jl implements Affine maps. It provides the function object types Mul, Add, MulAdd and AddMul, as well as their inverses.\n\nAll function objects defined here support the implement/support the APIs of\n\nInverseFunctions.jl\nChangesOfVariables.jl\nFunctors.jl\n\nExample:\n\nusing AffineMaps\nusing LinearAlgebra, InverseFunctions, ChangesOfVariables\nA = rand(5, 5)\nb = rand(5)\nx = rand(5)\n\nf = MulAdd(A, b)\ny = f(x)\ny ≈ A * x + b\n\ninverse(f)(y) ≈ x\n\ny, ladj = with_logabsdet_jacobian(f, x)\ny ≈ A * x + b && ladj ≈ logabsdet(A)[1]","category":"section"}]
}
